---
title: "Deck analysis"
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE} 
library(pander)
library("rjson")
library(tidyverse)
library(glmnet)
library(rFSA)
conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::lag)
conflicted::conflicts_prefer(dplyr::any_of)
conflicted::conflicts_prefer(purrr::discard)
source("../sources/S2_Source_mtg_new_card.R",local = TRUE)

# loaded_base_data <- readRDS("data/data_meta_en_cours.rds")

modern_DB_card <- read_csv("../data/mtg_data/DBcarte_modern.csv")

# sample size minimum pour etre un groupe


Land_modern <- modern_DB_card %>%
  filter(str_detect(type_line, "Land|land")) %>%
  # Remove dfc land exept dfc land // land
  filter(
    !str_detect(
      type_line,
      "(?<!Land )// Land"
    )
  ) %>%
  {
    . ->> tmp
  } %>%
  filter(str_detect(name, ".+ //")) %>%
  mutate(name = str_remove(name, " // .+")) %>%
  rbind(tmp)

rm(tmp)



df_export <- readRDS("../data/data_meta_en_cours.rds") %>%
      # include filter bad deck
  filter(Valide_deck) %>% 
  mutate(
    Deck_winrate = winrate_1_data(Wins, Losses)
  ) %>%
  mutate(
    Archetype_count = n()
  ) %>%
  filter(Archetype != "Unknown")




# a reflechir car pour le moment bloque les regroupement
 #  min(50, 
 # sum(unique(df_export$Archetype_count))*2/100 )

```

```{r}
knitr::read_chunk("../sources/S1_introduction_text.R")
```



```{r, Introduction_chunk_5_Deck_analysis, results='asis'}

```



```{r}
# Manque visual représentation of deck

# Projet detection automatiques des cartes nested par exemple : felidar et sahelli  dans l'idéal devrait détecter zulaport et bloodartist

# check with codetools::checkUsage(f) and all fun
```



```{r function}
findIntRuns <- function(run) {
  run <- sort(run)
  rundiff <- c(1, diff(run))
  difflist <- split(run, cumsum(rundiff != 1))
  unlist(lapply(difflist, function(x) {
    if (length(x) %in% 1:2) as.character(x) else paste0(x[1], "-", x[length(x)])
  }), use.names = FALSE)
}

name_list_of_df_with_arch <- function(list) {
  names(list) <- lapply(list, function(x) {
    as.character(x$Archetype[1])
  }) %>% unlist()

  return(list)
}

name_list_of_model_with_string <- function(list, string) {
  names(list) <- string
  return(list)
}





format_model_list <- function(model_list) {
  model_clean <- lapply(model_list, function(x) {
    
    
    # print(as.character(x$Model_any$Archetype))
    if(is.null(x$Model_any)){
      Model_any_encours <- NULL
      }else{
    Model_any_encours <- x$Model_any %>%
      gtsummary::tbl_regression(exponentiate = TRUE) %>%
      gtsummary::bold_labels() %>%
      gtsummary::add_n(location = "level") %>%
      gtsummary::modify_spanning_header(
        c(stat_n, estimate,
          #ci
          conf.low, p.value) ~
          paste0(
            "**", x$Model_any$Archetype, " N :",
            sum(x$Model_any$data$Wins + x$Model_any$data$Losses),
            "**"
          )
      )
    }
    if(is.null(x$Model_count)){
      Model_count_encours <- NULL
      }else{
    Model_count_encours <- x$Model_count %>%
      gtsummary::tbl_regression(exponentiate = TRUE) %>%
      gtsummary::bold_labels() %>%
      gtsummary::add_n(location = "level") %>%
      gtsummary::modify_spanning_header(
        c(stat_n, estimate, 
          #ci
          conf.low, p.value) ~
          paste0(
            "**", x$Model_count$Archetype, " N :",
            sum(x$Model_count$data$Wins + x$Model_count$data$Losses),
            "**"
          )
      )
      }
    return(
      list(
      Model_any = Model_any_encours,
      Model_count = Model_count_encours
    ))
  })

  return(model_clean)
}



model_unco_cards_fun <- function(df_fun,interaction_term ) {
  cols_fun <- df_fun %>% 
    select(ends_with("_CardName")) %>% 
    colnames() %>% 
    str_remove("_CardName")
  # unique(df_fun$Archetype)
  # x <- 'Storm'                  
  model_unco_fun <- lapply(
    unique(df_fun$Archetype),
    function(x) {
       # print(as.character(x))
      # if(x == "Scam") browser()
      df_model <- df_fun %>%
        # select(-Join_main_count) %>%
        filter(Archetype == x) %>%
        ungroup() %>%
        filter(!is.na(!!rlang::sym(paste0(cols_fun, "_CardName")))) %>%
        rowwise() %>%
        mutate(!!rlang::sym(paste0(cols_fun, "_Count")) := 
                 ifelse(
                   str_detect(!!rlang::sym(paste0(cols_fun, "_Count"))," ; "),
                   !!rlang::sym(paste0(cols_fun, "_Count")),
                   paste0(
                     findIntRuns(
                       as.numeric(
                         unlist(str_split(!!rlang::sym(paste0(cols_fun, "_Count")), "/"))))
                     , collapse = "/")
                 )
        ) %>%
        ungroup() %>%
        pivot_wider(
          names_from = !!rlang::sym(paste0(cols_fun, "_CardName")),
          values_from = !!rlang::sym(paste0(cols_fun, "_Count")),
          values_fill = "0"
        ) %>%
        select(-Archetype, -Player, -id, -Archetype_count, -Draws) %>%
        mutate(
          # Choose most common level as references
          across(
            where(is.character),
            ~ fct_infreq(as.factor(.))
          )
        ) %>% 
        # remove card with only 1+ like basic land fetch ....
        select(where(~n_distinct(.) > 1))
      
      model_unco_tot_fun <- df_fun %>%
        # select(-Join_main_count) %>%
        filter(Archetype == x) %>%
        ungroup() %>%
        filter(!is.na(!!rlang::sym(paste0(cols_fun, "_CardName")))) %>%
        rowwise() %>%
        mutate(!!rlang::sym(paste0(cols_fun, "_Count")) := 
                 ifelse(
                   str_detect(!!rlang::sym(paste0(cols_fun, "_Count"))," ; "),
                   !!rlang::sym(paste0(cols_fun, "_Count")),
                   paste0(
                     findIntRuns(
                       as.numeric(
                         unlist(str_split(!!rlang::sym(paste0(cols_fun, "_Count")), "/"))))
                     , collapse = "/")
                 )
        )  %>%
        ungroup() %>%
        pivot_wider(
          names_from = !!rlang::sym(paste0(cols_fun, "_CardName")),
          values_from = !!rlang::sym(paste0(cols_fun, "_Count")),
          values_fill = "0"
        ) %>%
        select(-Archetype, -Player, -id, -Archetype_count, -Draws) %>%
        mutate(
          # Choose most common level as references
          across(
            where(is.character),
            ~ factor(
              if_else(. == names(sort(table(.),
                                      decreasing = TRUE
              ))[1],
              names(sort(table(.),
                         decreasing = TRUE
              ))[1], "Other"
              ),
              levels = c(names(sort(table(.),
                                    decreasing = TRUE
              ))[1], "Other")
            )
          )
        ) %>% 
        # remove card with only 1+ like basic land fetch ....
        select(where(~n_distinct(.) > 1))
      
      if (nrow(df_model) == 0) {
        model_res <- NULL
        model_res_any <- NULL
      } else {
        # print(as.character(x))
        # if(x == "Necro") browser()
        # nb_x_var <- ncol(
        #   model.matrix( ~.,
        #                 dplyr::select(df_model, -c(Wins, Losses)))[, -1]
        #                  )
        # 
        # 
        # 
        # x_mat_count <- model.matrix( ~ #. +.^2
        #                          (.)^3, dplyr::select(df_model, -c(Wins, Losses)))[, -1]
        # 
        # y_count <- cbind(Losses =  df_model$Losses,
        #                  Wins = df_model$Wins
        #                  )
        # 
        # extract_coef <- function(model){
        #   as.data.frame(as.matrix(coef(model))) %>% 
        #     filter(s0 != 0)
        # }
        # 
        # cv_count <- cv.glmnet(
        #   x = x_mat_count,
        #   y = y_count,
        #   family = "binomial",
        #   penalty.factor = c(rep(0, nb_x_var),
        #                      rep(1,ncol(x_mat_count)-nb_x_var)
        #                      ),
        #   alpha = 1,  
        #   nfolds = 10
        #   )
        # 
        # model_lasso_count <- glmnet(
        #   x = x_mat_count,
        #   y = y_count,
        #   family = "binomial",
        #   penalty.factor = c(rep(0, nb_x_var),
        #                      rep(1,ncol(x_mat_count)-nb_x_var)
        #   ),
        #   lambda =  cv_count$lambda.min
        #   )
        
        
        model_res_any <- model_removing_alias_var(
          df = model_unco_tot_fun,
          interaction_fun = interaction_term[x]
        )
        
        model_res <- model_removing_alias_var(
          df = df_model,
          interaction_fun = interaction_term[x]
        )
          
        model_res_any$Archetype <- x
        model_res$Archetype <- x
      }
      return(
        list(
          Model_any = model_res_any,
          Model_count = model_res #,          model_lasso_count = model_lasso_count
        )
      )
    }
  ) %>%
    discard(is.null)
  
  return(model_unco_fun)
}


model_removing_alias_var <- function(df,interaction_fun){
 remove_string <-  df %>% 
                       select(-any_of(c("Wins", "Losses","Number_of_cards"))) %>%
   pivot_longer(everything()) %>% 
   distinct(value) %>%
   mutate(
     value = as.character(value),
     a = nchar(value)) %>% 
   arrange(desc(value)) %>% 
   pull(value) %>%
   # str_replace_all("\\-","\\\\-") %>% 
   # str_replace_all("/","\\/") %>% 
   paste0(collapse = "|")
 
 

 
          formula_model <- as.formula(
          paste0(
            "cbind(Wins, Losses) ~",
            paste0(
              paste0("`", df %>% 
                       select(-c(Wins, Losses)) %>% 
                       colnames(),"`"
                     
              ),collapse = "+"
            ),
            ifelse(unlist(interaction_fun) !="",
            paste0("+",unlist(interaction_fun)),
            "")
          )
        )
          
        model_init_base <- glm(formula_model,
                             data = df,
                             family = quasibinomial # binomial
        )
        
  ld.vars <- attributes(alias(model_init_base)$Complete)$dimnames[[1]] %>% 
    str_remove_all(remove_string) #%>% 
    # str_remove_all("/") %>% 
    # str_remove_all("-")

  if(length(ld.vars) ==0){
    res <- model_init_base
    
  } else {
    formula.new <- as.formula(
    paste(
        paste(deparse(formula_model), collapse=""), 
        paste(ld.vars, collapse="-"),
        sep="-"
    )
)
res <- glm(formula.new,
           data = df,
           family = quasibinomial # binomial
)
}
#remove the linearly dependent variables variables
return(res)
}
```

```{r linear_comb_function}
group_linear_comb_cards <- function(df_long){

  colname_deck_list <- df_long  %>% 
    select(ends_with("_CardName")) %>% 
    colnames() %>% str_remove("_CardName")
  
  
  df_wide_linear_comb <- df_long  %>%
    ungroup() %>%
    pivot_wider(
      names_from = !!rlang::sym(paste0(colname_deck_list, "_CardName")),
      values_from = !!rlang::sym(paste0(colname_deck_list, "_Count")),
       values_fill = "0",
      id_cols = c(Archetype,id)
      ) %>%
    group_split(Archetype)


res_group_df_to_join <- lapply(df_wide_linear_comb, function(x) {
  
  df_linear_comb_apply_encours <- x %>%
      select(where(~n_distinct(.) > 1)) %>%
  mutate(
    across(-c(id),
     ~as.numeric(
       factor(.,
             levels = gtools::mixedsort(unique(.))
                ))
               )
    ) %>%
    select(-id)
 linear_combo <-  caret::findLinearCombos(
   df_linear_comb_apply_encours
   )$linearCombos  

named_and_groups_combo <-  unique(sapply(linear_combo, function(x) 
       unique(unlist(linear_combo[sapply(linear_combo, function(y) 
                         any(x %in% y))])))) %>% 
  lapply(., function(x) colnames(df_linear_comb_apply_encours)[x])



df_res <- x 
if(length(named_and_groups_combo) > 0){
for (i in seq_along(named_and_groups_combo)){
  
  df_res <- df_res %>% 
    rowwise() %>% 
    mutate(
    !!rlang::sym(paste0(named_and_groups_combo[[i]], collapse = " ; ")) := 
                 # ifelse(
                  paste(!!!rlang::syms(named_and_groups_combo[[i]]), sep = " ; ")
    ) %>% 
    select(-all_of(named_and_groups_combo[[i]]))
                   
    # )
  
}
}

res <- df_res %>% 
  pivot_longer(-c(Archetype,id),
      names_to  = paste0(colname_deck_list, "_CardName"),
      values_to  = paste0(colname_deck_list, "_Count"),
               ) %>% 
  filter(!str_detect(!!rlang::sym(paste0(colname_deck_list, "_Count")),"^0") )
return(res)
 }
 ) %>% 
  bind_rows()

res <- res_group_df_to_join %>% 
left_join(df_long %>% 
  select(-c(Join_main_count),
         -all_of(c(paste0(colname_deck_list, "_CardName"),
                paste0(colname_deck_list, "_Count"))  
                  )) %>% 
  distinct(),
  by = join_by(Archetype,id)
  )

}
```



```{r compute_vif}
compute_vif_for_model <- function(res_model){
  
res_fun <- lapply(res_model, function (x){
  
res_per_arch <- lapply(seq_along(x), function(y){
  model_vif_fun <- x[[y]]
  
  print(as.character(x$Model_any$Archetype))
  if  (length(coefficients(model_vif_fun))  < 3){
  res <- data.frame(
    model = names(x[y]),
    name = "a",
    Df = 1,
    vif = 0
    ) %>% as_tibble()
    
  } else{
  vif_res <- car::vif(model_vif_fun)

  if(is.null(ncol(vif_res))){
  res <- data.frame(
    model = names(x[y]),
    name = names(vif_res),
    Df = 1,
    vif = vif_res
    ) %>% as_tibble() %>% 
    arrange(desc(vif))
} else {
  res = as.data.frame(vif_res) %>% 
    rownames_to_column("name") %>% 
    as_tibble() %>% 
    mutate(model = names(x[y]),
         .before = 1) %>% 
    select(-GVIF) %>% 
    rename(vif = `GVIF^(1/(2*Df))`) %>% 
    arrange(desc(vif))
  }
}}
) %>% 
  bind_rows() %>% 
  mutate(Archetype = x$Model_any$Archetype,
         .before = 1)  %>%  
  filter(vif > 3)
  
}) %>% 
  bind_rows()
return(res_fun)
}
```



```{r agreg_land_name}
df_Archetype_long <- df_export %>%
  filter(!is.na(Wins)) %>%
  rowwise() %>%
  filter(!is.null(Mainboard)) %>%
  filter(!is.null(Sideboard)) %>%
  ungroup() %>%
  group_by(Archetype) %>%
  mutate(
    Archetype_count = n()
  ) %>%
  filter(Archetype_count > filter_archetype_count_5) %>%
  arrange(desc(Archetype_count)) %>%
  unnest_longer(Mainboard) %>%
  unnest_wider(Mainboard, names_sep = "_") %>%
  # mutate(Mainboard_CardName = Card_agregueur(Mainboard_CardName)) %>%
  select(id, Player, Wins, Losses, Draws, Archetype, Mainboard_Count, Mainboard_CardName) %>%
  group_by(id) %>%
  mutate(Number_of_cards = sum(Mainboard_Count)) %>%
  filter(Number_of_cards >= 60) %>%
  ungroup() %>%
  mutate(
    Archetype =
      factor(Archetype,
        level = unique(.$Archetype)
      )
  )


Df_archetype_cards_land_name_agreg <- rbind(
  df_Archetype_long %>%
    group_by(Archetype) %>%
    mutate(Archetype_count = n_distinct(id)) %>%
    mutate(
      Mainboard_CardName =
        Card_agregueur(
          Mainboard_CardName,
          fetch = TRUE,
          Tron = TRUE,
          snow = TRUE,
          surveil = TRUE,
          shock = TRUE,
          triome = TRUE,
          filter_land = TRUE,
          fast_land = TRUE,
          bounce_land = TRUE,
          horizon_land = TRUE,
          basic_land = TRUE
        )
    ) %>%
    ungroup() %>%
    group_by(id, Mainboard_CardName) %>%
    mutate(
      Mainboard_Count = sum(Mainboard_Count)
    ) %>%
    distinct(id, Mainboard_CardName, .keep_all = TRUE),
  df_Archetype_long %>%
    mutate(
      Mainboard_Count = if_else(
        Mainboard_CardName %in% Land_modern$name,
        Mainboard_Count, 0
      ),
      Mainboard_CardName = "Land_tot"
    ) %>%
    group_by(id) %>%
    mutate(
      Mainboard_Count = sum(Mainboard_Count)
    ) %>%
    ungroup() %>%
    group_by(Archetype) %>%
    mutate(Archetype_count = n_distinct(id)) %>%
    ungroup() %>%
    distinct()
) %>%
  arrange(desc(Archetype_count), id)



Df_archetype_cards_agreg <- Df_archetype_cards_land_name_agreg %>%
  group_by(Archetype, Archetype_count, Mainboard_CardName, Mainboard_Count) %>%
  summarise(
    Wins = sum(Wins),
    Losses = sum(Losses),
    count_iteration_cards = n(),
    .groups = "drop"
  ) %>%
  group_by(Archetype, Mainboard_CardName) %>%
  mutate(
    Wins = sum(Wins),
    Losses = sum(Losses),
    total_number_of_copie = sum(count_iteration_cards),
    most_common_count = max(count_iteration_cards)
  ) %>% 
  filter(total_number_of_copie >= min_sample_size_5)
```




```{r}
Deck_win_rate_join <- df_Archetype_long %>%
  ungroup() %>%
  distinct(id,.keep_all = TRUE) %>% 
  group_by(Archetype) %>%
  summarise(Archetype_winrate = sum(Wins)/(sum(Wins) + sum(Losses))
              ) %>% 
  ungroup()
```



```{r agreg_sideboard}
df_side_Archetype_long <- df_export %>%
  # remove deck with less than 60 cards or no side / no main or with not enought data in arch
  filter(id %in% unique(df_Archetype_long$id)) %>%
  group_by(Archetype) %>%
  mutate(
    Archetype_count = n()
  ) %>%
  arrange(desc(Archetype_count)) %>%
  unnest_longer(Sideboard) %>%
  unnest_wider(Sideboard, names_sep = "_") %>%
  select(id, Player, Wins, Losses, Draws, Archetype, Sideboard_CardName, Sideboard_Count) %>%
  mutate(
    Archetype =
      factor(Archetype,
        level = unique(.$Archetype)
      )
  ) %>%
  group_by(Archetype) %>%
  mutate(Archetype_count = n_distinct(id)) %>%
  ungroup()



Df_side_archetype_cards_agreg <- df_side_Archetype_long %>%
  group_by(Archetype, Archetype_count, Sideboard_CardName, Sideboard_Count) %>%
  summarise(
    Wins = sum(Wins),
    Losses = sum(Losses),
    count_iteration_cards = n(),
    .groups = "drop"
  ) %>%
  group_by(Archetype, Sideboard_CardName) %>%
  mutate(
    Wins = sum(Wins),
    Losses = sum(Losses),
    total_number_of_copie = sum(count_iteration_cards),
    most_common_count = max(count_iteration_cards)
  ) %>% 
  filter(total_number_of_copie >= min_sample_size_5)
```


```{r uncommon_cards}
Uncommon_cards_pre_process <- Df_archetype_cards_agreg %>%
  # filter(count_iteration_cards == most_common_count) %>%
  filter(
    (Archetype_count - most_common_count) >= min_sample_size_5,
    # most_common_count >= min_sample_size_5
    # (Archetype_count - total_number_of_copie) >= min_sample_size_5,
    total_number_of_copie >= min_sample_size_5
  ) %>%
  group_by(Archetype, Mainboard_CardName) %>%
  mutate(
    # Choix de prendre la plus faible quantité en cas d'éaglité pour le plus commun
    most_common_quantity = Mainboard_Count[count_iteration_cards == max(count_iteration_cards)][1],
    min_count_group = Mainboard_Count
  )




Uncommon_cards_agreg_out <- Agreg_count_by_cards(
  Uncommon_cards_pre_process,
  "Mainboard",
  min_sample_size_5
)

Uncommon_cards <- Uncommon_cards_agreg_out %>%
  group_by(Archetype, Mainboard_CardName)
```


```{r Side_uncommon_cards}
Side_Uncommon_cards_pre_process <- Df_side_archetype_cards_agreg %>%
  # filter(count_iteration_cards == most_common_count) %>%
  filter(
    (Archetype_count - most_common_count) >= min_sample_size_5,
    # most_common_count >= min_sample_size_5
    # (Archetype_count - total_number_of_copie) >= min_sample_size_5,
    total_number_of_copie >= min_sample_size_5
  ) %>%
  group_by(Archetype, Sideboard_CardName) %>%
  mutate(
    # Choix de prendre la plus faible quantité en cas d'éaglité pour le plus commun
    most_common_quantity = Sideboard_Count[count_iteration_cards == max(count_iteration_cards)][1],
    min_count_group = Sideboard_Count
  )




Side_Uncommon_cards_agreg_out <- Agreg_count_by_cards(
  Side_Uncommon_cards_pre_process,
  "Sideboard",
  min_sample_size_5
)

Side_Uncommon_cards <- Side_Uncommon_cards_agreg_out %>%
  group_by(Archetype, Sideboard_CardName)
```




```{r Base_cards_grouping_with_agreg}
# Récupération des cartes a 1 niveaux après agreg
Base_cards_and_base_count <- rbind(
  Df_archetype_cards_agreg %>%
    mutate(
      min_count_group = Mainboard_Count,
      most_common_quantity = Mainboard_Count
    ) %>%
    group_by(Archetype, Mainboard_CardName) %>%
    mutate(Mainboard_Count = paste0(Mainboard_Count, collapse = "/")) %>%
    ungroup() %>%
    filter(count_iteration_cards == most_common_count) %>%
    filter((Archetype_count - most_common_count) < min_sample_size_5),
  Uncommon_cards_agreg_out %>%
    group_by(Archetype, Mainboard_CardName) %>%
    filter(n() == 1)
) %>%
  rowwise() %>%
  mutate(Mainboard_Count = paste0(findIntRuns(as.numeric(unlist(str_split(Mainboard_Count, "/")))), collapse = "/")) %>%
  ungroup() %>%
  left_join(Deck_win_rate_join,by = "Archetype") %>% 
  group_split(Archetype) %>%
  name_list_of_df_with_arch()
```


```{r Side_Base_cards_grouping_with_agreg}
# Récupération des cartes a 1 niveaux après agreg
Side_Base_cards_and_base_count <- rbind(
  Df_side_archetype_cards_agreg %>%
    mutate(
      min_count_group = Sideboard_Count,
      most_common_quantity = Sideboard_Count
    ) %>%
    group_by(Archetype, Sideboard_CardName) %>%
    mutate(Sideboard_Count = paste0(Sideboard_Count, collapse = "/")) %>%
    ungroup() %>%
    filter(count_iteration_cards == most_common_count) %>%
    filter((Archetype_count - most_common_count) < min_sample_size_5),
  Side_Uncommon_cards_agreg_out %>%
    group_by(Archetype, Sideboard_CardName) %>%
    filter(n() == 1)
) %>%
  rowwise() %>%
  mutate(Sideboard_Count = paste0(findIntRuns(as.numeric(unlist(str_split(Sideboard_Count, "/")))), collapse = "/")) %>%
  ungroup() %>%
  left_join(Deck_win_rate_join,by = "Archetype") %>% 
  group_split(Archetype) %>%
  name_list_of_df_with_arch()
```




```{r groupe_cards}
compute_pairwise_table <- function(df_fun_cor_cat,seuil_common_sup = 0.9){
  
list_of_pairwise_table <- lapply(
  apply(combn(names(df_fun_cor_cat), 2), 2, 
                                       function(i) df_fun_cor_cat[i]),
  function(x) {
    card_name <-  colnames(x)
    df_en_cours <-  x %>% 
        rename(card1 = 1,
          card2 = 2,
          ) %>% 
  filter(!(card1 == "0" & card2 == "0"))
    
    count_card1 <- df_en_cours %>%
    count(card1) %>% 
      rename(count_card1 = 1 ,
             n_card1 = 2
             ) %>% 
      mutate(
        card1 = card_name[1],
           total_card1 = sum(df_en_cours$card1 !=0)
          ) 
    
    count_card2 <- df_en_cours %>%
    count(card2) %>% 
      rename(
        count_card2 = 1 ,
        n_card2 = 2     
             ) %>% 
      mutate(card2 = card_name[2],
             total_card2 = sum(df_en_cours$card2 !=0)
             )
    # slower 134.33 sec vs 77.32 sec
     # x %>% 
     #  count(., !!!.) %>% 
  res <-  as.data.frame(table(x)) %>%
  mutate(card1 = card_name[1],
         .before = 1
         ) %>%
  mutate(
      card2 = card_name[2],
      .before = 3
  ) %>%
  rename(count_card1 = 2,
         count_card2 = 4,
         ) %>% 
   left_join(count_card1,by = join_by(card1, count_card1)) %>% 
    left_join(count_card2,by = join_by(card2, count_card2))
  
  return(res)
  }
# )
  ) %>%
  bind_rows() %>% 
  filter(!(count_card1 == "0" | count_card2 == "0")) %>%
  drop_na() %>% 
  rowwise() %>%
  mutate(
    MIN_COL_name = c("card1","card2")[which.min(c_across(c(n_card1,n_card2)))],
    # percent_support = Freq/min(n_card1,n_card2),
    percent_support = Freq/min(total_card1 ,total_card2 )
    ) %>%
  select(-c(n_card1,n_card2)) %>% 
  group_by(card1,card2) %>% 
  summarise(percent_support = max(percent_support),.groups = "drop") %>% 
  ungroup() %>% 
    filter(
    percent_support > (seuil_common_sup)) %>%
  arrange(desc(percent_support)) 

return(list_of_pairwise_table)
}


##########################################################################################################################################################################################################

group_variable_function <- function(df_arch_init,seuil_common_sup){

   Archetype_en_cours <- unique(df_arch_init$Archetype)
    df_fun_cor_cat_arch <- df_arch_init %>%
      select(-c(
        id 
      )) %>%
      select(-ends_with(" land"), -any_of("Land_tot")) %>%
      select(where(~ n_distinct(.) > 1))
    # print(as.character(Archetype_en_cours))
    if (ncol(df_fun_cor_cat_arch) <= 1) {
      # list_of_pairwise_table <- NULL
      res <- ""
    } else {
      list_of_pairwise_table_en_cours <- compute_pairwise_table(
        df_fun_cor_cat = df_fun_cor_cat_arch,
        seuil_common_sup = seuil_common_sup
      ) %>% 
        rowwise() %>% 
        mutate(result = paste0("`",card1,"`",":","`",card2,"`"))
      res <- paste0(list_of_pairwise_table_en_cours$result,collapse = "+")
    }


return(res)
}

```





```{r model_unco_cards}
Model_data_Uncommon_cards <- prepare_df_for_model(
  df_fun = Uncommon_cards,
  base_df = Df_archetype_cards_land_name_agreg,
  cols_fun = "Mainboard"
  ) 

```





```{r}
groupe_cards_uncommon_data <- group_linear_comb_cards(Model_data_Uncommon_cards)
```


```{r}
# df_arch_init <- df_uncommon_cards_grouping_fun[[23]]
all_archetype_table_for_all_cards <- lapply(
  groupe_cards_uncommon_data  %>%
  ungroup() %>%
  pivot_wider(
    names_from = Mainboard_CardName,
    values_from = Mainboard_Count,
     values_fill = "0",
    id_cols = c(Archetype,id)
    )  %>%
  group_split(Archetype),
  function(x) {
    res <- group_variable_function(df_arch_init = x,
                                             seuil_common_sup = 0.95)
    return(res)
  }
) %>%
  name_list_of_model_with_string(unique(groupe_cards_uncommon_data$Archetype))

```





```{r}
# groupe_cards_uncommon_data  <- all_archetype_table_for_all_cards %>% 
#   filter(Mainboard_Count != "0") %>% 
#   left_join(
#     (Model_data_Uncommon_cards %>%
#               select(-c(Mainboard_CardName,Mainboard_Count,-Join_main_count)) %>% 
#               distinct(id,.keep_all = TRUE)),
#             by = join_by(
#    Archetype,id
#   )
#   )


```





```{r}
# Projet avec les images des cartes pour arborescence deck list penser a mettre en gras le compte le plus rreprésenter pour base card and base count
result_models_Uncommon_cards_all_arch <- model_unco_cards_fun(
  df_fun = groupe_cards_uncommon_data,
  # Model_data_Uncommon_cards, 
  interaction_term = all_archetype_table_for_all_cards
  ) %>%
  name_list_of_model_with_string(unique(groupe_cards_uncommon_data$Archetype))

```


```{r format_main_models}
uncomon_card_format_model <- format_model_list(result_models_Uncommon_cards_all_arch) %>%
  name_list_of_model_with_string(unique(groupe_cards_uncommon_data$Archetype))
```





```{r side_model_unco_cards}
Side_Model_data_Uncommon_cards <-  prepare_df_for_model(
  df_fun = Side_Uncommon_cards,
  base_df = df_side_Archetype_long,
  cols_fun = "Sideboard"
  )
# Projet avec les images des cartes pour arborescence deck list penser a mettre en gras le compte le plus rreprésenter pour base card and base count
```



```{r}
# tictoc::tic("table cards")
# df_uncommon_side_cards_grouping_fun <- Side_Model_data_Uncommon_cards  %>% 
#   ungroup() %>%
#   pivot_wider(
#     names_from = Sideboard_CardName,
#     values_from = Sideboard_Count,
#      values_fill = "0",
#     id_cols = c(Archetype,id)
#     )  %>% 
#   group_split(Archetype)
# 
# 
# all_archetype_table_for_side_all_cards <- lapply(
#   df_uncommon_side_cards_grouping_fun,
#   function(x) {
#     # print(as.character(unique(x$Archetype)))
#     res_iteration <- group_variable_function(df_arch_init = x,
# seuil_common_sup = 0.95)
# 
#     res <- res_iteration %>% 
#       pivot_longer(
#         cols = -c(Archetype,id),
#         names_to = "Sideboard_CardName",
#         values_to = "Sideboard_Count"
#                    )
#     return(res)
#   }
# ) %>% 
#   bind_rows() 


# tictoc::toc()
```


```{r}
# groupe_side_cards_uncommon_data  <- all_archetype_table_for_side_all_cards %>% 
#   filter(Sideboard_Count != "0") %>% 
#   left_join(
#     (
#       Side_Model_data_Uncommon_cards %>%
#               select(-c(Sideboard_CardName,Sideboard_Count,-Join_main_count)) %>% 
#               distinct(id,.keep_all = TRUE)
#       ),
#             by = join_by(
#    Archetype,id
#   )
#   ) 

groupe_side_cards_uncommon_data <- group_linear_comb_cards(Side_Model_data_Uncommon_cards)

all_archetype_table_for_side_cards <- lapply(
  groupe_side_cards_uncommon_data  %>%
  ungroup() %>%
  pivot_wider(
    names_from = Sideboard_CardName,
    values_from = Sideboard_Count,
     values_fill = "0",
    id_cols = c(Archetype,id)
    )  %>%
  group_split(Archetype),
  function(x) {
    res <- group_variable_function(df_arch_init = x,
                                             seuil_common_sup = 0.95)
    return(res)
  }
) %>%
  name_list_of_model_with_string(unique(groupe_side_cards_uncommon_data$Archetype))
```


```{r}
Side_result_models_Uncommon_cards_all_arch <- model_unco_cards_fun(
  groupe_side_cards_uncommon_data,
  interaction_term = all_archetype_table_for_side_cards
  ) %>%
  name_list_of_model_with_string(unique(groupe_side_cards_uncommon_data$Archetype))
```




```{r format_side_models}
Side_uncomon_card_format_model <- format_model_list(Side_result_models_Uncommon_cards_all_arch) %>%
  name_list_of_model_with_string(unique(groupe_side_cards_uncommon_data$Archetype))
```




```{r}

vif_deck <- rbind(
  compute_vif_for_model(result_models_Uncommon_cards_all_arch) %>% 
    mutate(
      deck_side = "Main",.before = 1
      ),
  compute_vif_for_model(Side_result_models_Uncommon_cards_all_arch) %>% 
    mutate(
      deck_side = "Main",.before = 1
      )
  )

```


```{r print_result, results='asis', out.width="100%"}
if(is_inside_knitr()){
for (i in sort(levels(df_Archetype_long$Archetype))) {
  # Inserts Month titles
  pander::pandoc.header(i, level = 1)
  # Section contents
  pander::pandoc.header("Main deck", level = 2)
  pander::pandoc.p("")


  if (i %in% names(Base_cards_and_base_count)) {
  pander::pandoc.header("Base Cards", level = 3)
  pander::pandoc.p("")
  pander::pandoc.p("Cards Always in deck with nearly fix count")
  pander::pandoc.p("")

    flextable::flextable_to_rmd(
      flextable::flextable(
        Base_cards_and_base_count[[i]] %>%
          mutate(
            WR = paste0(round(((Wins  / (Wins + Losses)) - Archetype_winrate)* 100, 2), " %"),
            Not_most_common_count = total_number_of_copie - most_common_count,
            Card_not_in_deck = Archetype_count - total_number_of_copie
          ) %>%
          select(
            Mainboard_CardName, WR, Mainboard_Count,
            most_common_quantity, Card_not_in_deck, Not_most_common_count
          )
      ) %>% flextable::align(align = "center", part = "all")
    )
  }


  if (i %in% names(uncomon_card_format_model)) {
  pander::pandoc.header("Variable Cards", level = 3)
  pander::pandoc.p("")
  pander::pandoc.p("Cards not always in deck using binomial regression for WR")
  pander::pandoc.p("")
    pander::pandoc.p('::: {.panel-tabset .nav-pills}')
if (!is.null(uncomon_card_format_model[[i]]$Model_any)) {
    pander::pandoc.header("Any", level = 4)
    flextable::flextable_to_rmd(
      uncomon_card_format_model[[i]]$Model_any %>%
        gtsummary::as_flex_table()
    )
}
    pander::pandoc.p("")
    # pander::pandoc.p(":::")
    #
    # pander::pandoc.p('::: {.column width="50%"}')
    pander::pandoc.p("")
    if (!is.null(uncomon_card_format_model[[i]]$Model_count )) {
    pander::pandoc.header("Count", level = 4)
    flextable::flextable_to_rmd(
      uncomon_card_format_model[[i]]$Model_count %>%
        gtsummary::as_flex_table()
    )
}
#     pander::pandoc.p(":::
# ::::::::::::::")
    pander::pandoc.p(":::")
  }
  # adding also empty lines, to be sure that this is valid Markdown
  pander::pandoc.p("")
  pander::pandoc.p("")

  pander::pandoc.header("Side Board", level = 2)
  pander::pandoc.p("")


  if (i %in% names(Side_Base_cards_and_base_count)) {
  pander::pandoc.header("Base Cards", level = 3)
  pander::pandoc.p("")
  pander::pandoc.p("Cards Always in deck with nearly fix count")
  pander::pandoc.p("")
   flextable::flextable_to_rmd(
      flextable::flextable(
        Side_Base_cards_and_base_count[[i]] %>%
          mutate(
            WR = paste0(round(((Wins  / (Wins + Losses)) - Archetype_winrate)* 100, 2), " %"),
            Not_most_common_count = total_number_of_copie - most_common_count,
            Card_not_in_deck = Archetype_count - total_number_of_copie
          ) %>%
          select(
            Sideboard_CardName, WR, Sideboard_Count,
            most_common_quantity, Card_not_in_deck, Not_most_common_count
          )
      ) %>%
        flextable::align(align = "center", part = "all")
    )
  }

  if (i %in% names(uncomon_card_format_model)) {
  pander::pandoc.header("Variable Cards", level = 3)
  pander::pandoc.p("")
  pander::pandoc.p("Cards not always in deck using binomial regression for WR")
  pander::pandoc.p("")

#     pander::pandoc.p(':::::::::::::: {.columns}
# ::: {.column width="50%"}')

    pander::pandoc.p('::: {.panel-tabset .nav-pills}')
    if (!is.null(Side_uncomon_card_format_model[[i]]$Model_any)) {
       pander::pandoc.header("Any", level = 4)
    flextable::flextable_to_rmd(
      Side_uncomon_card_format_model[[i]]$Model_any %>%
        gtsummary::as_flex_table()
    )
}
    # pander::pandoc.p(":::")
    #
    # pander::pandoc.p('::: {.column width="50%"}')
    pander::pandoc.p("")
if (!is.null(Side_uncomon_card_format_model[[i]]$Model_count)) {
     pander::pandoc.header("Count", level = 4)
    flextable::flextable_to_rmd(
      Side_uncomon_card_format_model[[i]]$Model_count %>%
        gtsummary::as_flex_table()
    )
}
#     pander::pandoc.p(":::
# ::::::::::::::")
    pander::pandoc.p(":::")
  }
  # adding also empty lines, to be sure that this is valid Markdown
  pander::pandoc.p("")
  pander::pandoc.p("")



  pander::pandoc.p("")
  pander::pandoc.p("")
}
  }
```








