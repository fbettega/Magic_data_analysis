---
title: "Deck analysis"
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE} 
library(pander)
library("rjson")
library(tidyverse)
conflicted::conflicts_prefer(dplyr::filter)
conflicted::conflicts_prefer(dplyr::lag)
conflicted::conflicts_prefer(dplyr::any_of)
conflicted::conflicts_prefer(purrr::discard)
source("../sources/S2_Source_mtg_new_card.R",local = TRUE)

# loaded_base_data <- readRDS("data/data_meta_en_cours.rds")

modern_DB_card <- read_csv("../data/mtg_data/DBcarte_modern.csv")

# sample size minimum pour etre un groupe


Land_modern <- modern_DB_card %>%
  filter(str_detect(type_line, "Land|land")) %>%
  # Remove dfc land exept dfc land // land
  filter(
    !str_detect(
      type_line,
      "(?<!Land )// Land"
    )
  ) %>%
  {
    . ->> tmp
  } %>%
  filter(str_detect(name, ".+ //")) %>%
  mutate(name = str_remove(name, " // .+")) %>%
  rbind(tmp)

rm(tmp)



df_export <- readRDS("../data/data_meta_en_cours.rds") %>%
      # include filter bad deck
  filter(Valide_deck) %>% 
  mutate(
    Deck_winrate = winrate_1_data(Wins, Losses)
  ) %>%
  mutate(
    Archetype_count = n()
  ) %>%
  filter(Archetype != "Unknown")




# a reflechir car pour le moment bloque les regroupement
 #  min(50, 
 # sum(unique(df_export$Archetype_count))*2/100 )

```

```{r}
knitr::read_chunk("../sources/S2_Source_mtg_new_card.R")
```



```{r, Introduction_chunk_5_Deck_analysis, results='asis'}

```



```{r}
# Manque visual représentation of deck

# Projet detection automatiques des cartes nested par exemple : felidar et sahelli  dans l'idéal devrait détecter zulaport et bloodartist

# check with codetools::checkUsage(f) and all fun
```



```{r function}
findIntRuns <- function(run) {
  run <- sort(run)
  rundiff <- c(1, diff(run))
  difflist <- split(run, cumsum(rundiff != 1))
  unlist(lapply(difflist, function(x) {
    if (length(x) %in% 1:2) as.character(x) else paste0(x[1], "-", x[length(x)])
  }), use.names = FALSE)
}

name_list_of_df_with_arch <- function(list) {
  names(list) <- lapply(list, function(x) {
    as.character(x$Archetype[1])
  }) %>% unlist()

  return(list)
}

name_list_of_model_with_string <- function(list, string) {
  names(list) <- string
  return(list)
}





format_model_list <- function(model_list) {
  model_clean <- lapply(model_list, function(x) {
    
    
    # print(as.character(x$Model_any$Archetype))
    if(is.null(x$Model_any)){
      Model_any_encours <- NULL
      }else{
    Model_any_encours <- x$Model_any %>%
      gtsummary::tbl_regression(exponentiate = TRUE) %>%
      gtsummary::bold_labels() %>%
      gtsummary::add_n(location = "level") %>%
      gtsummary::modify_spanning_header(
        c(stat_n, estimate,
          #ci
          conf.low, p.value) ~
          paste0(
            "**", x$Model_any$Archetype, " N :",
            sum(x$Model_any$data$Wins + x$Model_any$data$Losses),
            "**"
          )
      )
    }
    if(is.null(x$Model_count)){
      Model_count_encours <- NULL
      }else{
    Model_count_encours <- x$Model_count %>%
      gtsummary::tbl_regression(exponentiate = TRUE) %>%
      gtsummary::bold_labels() %>%
      gtsummary::add_n(location = "level") %>%
      gtsummary::modify_spanning_header(
        c(stat_n, estimate, 
          #ci
          conf.low, p.value) ~
          paste0(
            "**", x$Model_count$Archetype, " N :",
            sum(x$Model_count$data$Wins + x$Model_count$data$Losses),
            "**"
          )
      )
      }
    return(
      list(
      Model_any = Model_any_encours,
      Model_count = Model_count_encours
    ))
  })

  return(model_clean)
}





# Function that create model for unco cards
# Function that create model for unco cards
model_unco_cards_fun <- function(df_fun, cols_fun) {
  
  # unique(df_fun$Archetype)
  # x <- 'Nadu'                  
  model_unco_fun <- lapply(
    unique(df_fun$Archetype),
    function(x) {
      # print(as.character(x))
      # if(x == "Scam") browser()
      df_model <- df_fun %>%
        select(-Join_main_count) %>%
        filter(Archetype == x) %>%
        ungroup() %>%
        filter(!is.na(!!rlang::sym(paste0(cols_fun, "_CardName")))) %>%
        rowwise() %>%
        mutate(!!rlang::sym(paste0(cols_fun, "_Count")) := 
                 ifelse(
                   str_detect(!!rlang::sym(paste0(cols_fun, "_Count"))," : "),
                   !!rlang::sym(paste0(cols_fun, "_Count")),
                 paste0(
          findIntRuns(
            as.numeric(
              unlist(str_split(!!rlang::sym(paste0(cols_fun, "_Count")), "/"))))
          , collapse = "/")
          )
          ) %>%
        ungroup() %>%
        pivot_wider(
          names_from = !!rlang::sym(paste0(cols_fun, "_CardName")),
          values_from = !!rlang::sym(paste0(cols_fun, "_Count")),
          values_fill = "0"
        ) %>%
        select(-Archetype, -Player, -id, -Archetype_count, -Draws) %>%
        mutate(
          # Choose most common level as references
          across(
            where(is.character),
            ~ fct_infreq(as.factor(.))
          )
        ) %>% 
        # remove card with only 1+ like basic land fetch ....
        select(where(~n_distinct(.) > 1))
      
      model_unco_tot_fun <- df_fun %>%
        select(-Join_main_count) %>%
        filter(Archetype == x) %>%
        ungroup() %>%
        filter(!is.na(!!rlang::sym(paste0(cols_fun, "_CardName")))) %>%
        rowwise() %>%
        mutate(!!rlang::sym(paste0(cols_fun, "_Count")) := 
                        ifelse(
                          str_detect(!!rlang::sym(paste0(cols_fun, "_Count"))," : "),
                          !!rlang::sym(paste0(cols_fun, "_Count")),
                          paste0(
                            findIntRuns(
                              as.numeric(
                                unlist(str_split(!!rlang::sym(paste0(cols_fun, "_Count")), "/"))))
                            , collapse = "/")
                        )
        )  %>%
        ungroup() %>%
        pivot_wider(
          names_from = !!rlang::sym(paste0(cols_fun, "_CardName")),
          values_from = !!rlang::sym(paste0(cols_fun, "_Count")),
          values_fill = "0"
        ) %>%
        select(-Archetype, -Player, -id, -Archetype_count, -Draws) %>%
        mutate(
          # Choose most common level as references
          across(
            where(is.character),
            ~ factor(
              if_else(. == names(sort(table(.),
                                      decreasing = TRUE
              ))[1],
              names(sort(table(.),
                         decreasing = TRUE
              ))[1], "Other"
              ),
              levels = c(names(sort(table(.),
                                    decreasing = TRUE
              ))[1], "Other")
            )
          )
        ) %>% 
        # remove card with only 1+ like basic land fetch ....
        select(where(~n_distinct(.) > 1))
      
      if (nrow(df_model) == 0) {
        model_res <- NULL
        model_res_any <- NULL
      } else {
        model_res_any <- glm(cbind(Wins, Losses) ~ .,
                             data = model_unco_tot_fun,
                             family = quasibinomial # binomial
        )
        
        model_res <- glm(cbind(Wins, Losses) ~ .,
                         data = df_model,
                         family = quasibinomial # binomial
        )
        model_res_any$Archetype <- x
        model_res$Archetype <- x
      }
      return(
        list(
          Model_any = model_res_any,
          Model_count = model_res
        )
      )
    }
  ) %>%
    discard(is.null)
  
  return(model_unco_fun)
}


```




```{r agreg_land_name}
df_Archetype_long <- df_export %>%
  filter(!is.na(Wins)) %>%
  rowwise() %>%
  filter(!is.null(Mainboard)) %>%
  filter(!is.null(Sideboard)) %>%
  ungroup() %>%
  group_by(Archetype) %>%
  mutate(
    Archetype_count = n()
  ) %>%
  filter(Archetype_count > filter_archetype_count_5) %>%
  arrange(desc(Archetype_count)) %>%
  unnest_longer(Mainboard) %>%
  unnest_wider(Mainboard, names_sep = "_") %>%
  # mutate(Mainboard_CardName = Card_agregueur(Mainboard_CardName)) %>%
  select(id, Player, Wins, Losses, Draws, Archetype, Mainboard_Count, Mainboard_CardName) %>%
  group_by(id) %>%
  mutate(Number_of_cards = sum(Mainboard_Count)) %>%
  filter(Number_of_cards >= 60) %>%
  ungroup() %>%
  mutate(
    Archetype =
      factor(Archetype,
        level = unique(.$Archetype)
      )
  )


Df_archetype_cards_land_name_agreg <- rbind(
  df_Archetype_long %>%
    group_by(Archetype) %>%
    mutate(Archetype_count = n_distinct(id)) %>%
    mutate(
      Mainboard_CardName =
        Card_agregueur(
          Mainboard_CardName,
          fetch = TRUE,
          Tron = TRUE,
          snow = TRUE,
          surveil = TRUE,
          shock = TRUE,
          triome = TRUE,
          filter_land = TRUE,
          fast_land = TRUE,
          bounce_land = TRUE,
          horizon_land = TRUE,
          basic_land = TRUE
        )
    ) %>%
    ungroup() %>%
    group_by(id, Mainboard_CardName) %>%
    mutate(
      Mainboard_Count = sum(Mainboard_Count)
    ) %>%
    distinct(id, Mainboard_CardName, .keep_all = TRUE),
  df_Archetype_long %>%
    mutate(
      Mainboard_Count = if_else(
        Mainboard_CardName %in% Land_modern$name,
        Mainboard_Count, 0
      ),
      Mainboard_CardName = "Land_tot"
    ) %>%
    group_by(id) %>%
    mutate(
      Mainboard_Count = sum(Mainboard_Count)
    ) %>%
    ungroup() %>%
    group_by(Archetype) %>%
    mutate(Archetype_count = n_distinct(id)) %>%
    ungroup() %>%
    distinct()
) %>%
  arrange(desc(Archetype_count), id)



Df_archetype_cards_agreg <- Df_archetype_cards_land_name_agreg %>%
  group_by(Archetype, Archetype_count, Mainboard_CardName, Mainboard_Count) %>%
  summarise(
    Wins = sum(Wins),
    Losses = sum(Losses),
    count_iteration_cards = n(),
    .groups = "drop"
  ) %>%
  group_by(Archetype, Mainboard_CardName) %>%
  mutate(
    Wins = sum(Wins),
    Losses = sum(Losses),
    total_number_of_copie = sum(count_iteration_cards),
    most_common_count = max(count_iteration_cards)
  ) %>% 
  filter(total_number_of_copie >= min_sample_size_5)
```







```{r}
Deck_win_rate_join <- df_Archetype_long %>%
  ungroup() %>%
  distinct(id,.keep_all = TRUE) %>% 
  group_by(Archetype) %>%
  summarise(Archetype_winrate = sum(Wins)/(sum(Wins) + sum(Losses))
              ) %>% 
  ungroup()
```



```{r agreg_sideboard}
df_side_Archetype_long <- df_export %>%
  # remove deck with less than 60 cards or no side / no main or with not enought data in arch
  filter(id %in% unique(df_Archetype_long$id)) %>%
  group_by(Archetype) %>%
  mutate(
    Archetype_count = n()
  ) %>%
  arrange(desc(Archetype_count)) %>%
  unnest_longer(Sideboard) %>%
  unnest_wider(Sideboard, names_sep = "_") %>%
  select(id, Player, Wins, Losses, Draws, Archetype, Sideboard_CardName, Sideboard_Count) %>%
  mutate(
    Archetype =
      factor(Archetype,
        level = unique(.$Archetype)
      )
  ) %>%
  group_by(Archetype) %>%
  mutate(Archetype_count = n_distinct(id)) %>%
  ungroup()



Df_side_archetype_cards_agreg <- df_side_Archetype_long %>%
  group_by(Archetype, Archetype_count, Sideboard_CardName, Sideboard_Count) %>%
  summarise(
    Wins = sum(Wins),
    Losses = sum(Losses),
    count_iteration_cards = n(),
    .groups = "drop"
  ) %>%
  group_by(Archetype, Sideboard_CardName) %>%
  mutate(
    Wins = sum(Wins),
    Losses = sum(Losses),
    total_number_of_copie = sum(count_iteration_cards),
    most_common_count = max(count_iteration_cards)
  ) %>% 
  filter(total_number_of_copie >= min_sample_size_5)
```


```{r}
# a <- df_Archetype_long %>% filter(Archetype == "Nadu")
# 
# write_rds(a,"test_list.rds")
```

```{r base_card_and_variable_count}
# First because of cards with 1 level after agreg
# Base_cards_and_variable_count_pre_process <- Df_archetype_cards_agreg %>%
#   # filter(count_iteration_cards == most_common_count) %>%
#   filter(
#     #Not in base cards fix count
#     (Archetype_count - most_common_count) >= min_sample_size_5,
#     # most_common_count >= min_sample_size_5
#     (Archetype_count - total_number_of_copie) < min_sample_size_5
#   ) %>%
#   group_by(Archetype, Mainboard_CardName) %>%
#   mutate(
#     # Choix de prendre la plus faible quantité en cas d'éaglité pour le plus commun
#     most_common_quantity = Mainboard_Count[count_iteration_cards == max(count_iteration_cards)][1],
#     min_count_group = Mainboard_Count
#   )
# 
# Base_cards_and_variable_count_agreg_out <- Agreg_count_by_cards(
#   Base_cards_and_variable_count_pre_process,
#   "Mainboard",
#   min_sample_size_5
# )
# 
# Base_cards_and_variable_count <- Base_cards_and_variable_count_agreg_out %>%
#   group_by(Archetype, Mainboard_CardName) %>%
#   filter(n() > 1)
```


```{r side_base_card_and_variable_count}
# First because of cards with 1 level after agreg
# Side_Base_cards_and_variable_count_pre_process <- Df_side_archetype_cards_agreg %>%
#   # filter(count_iteration_cards == most_common_count) %>%
#   filter(
#     (Archetype_count - most_common_count) >= min_sample_size_5,
#     # most_common_count >= min_sample_size_5
#     (Archetype_count - total_number_of_copie) < min_sample_size_5
#   ) %>%
#   group_by(Archetype, Sideboard_CardName) %>%
#   mutate(
#     # Choix de prendre la plus faible quantité en cas d'éaglité pour le plus commun
#     most_common_quantity = Sideboard_Count[count_iteration_cards == max(count_iteration_cards)][1],
#     min_count_group = Sideboard_Count
#   )
# 
# 
# Side_Base_cards_and_variable_count_agreg_out <- Agreg_count_by_cards(
#   Side_Base_cards_and_variable_count_pre_process,
#   "Sideboard",
#   min_sample_size_5
# )
# 
# 
# Side_Base_cards_and_variable_count <- Side_Base_cards_and_variable_count_agreg_out %>%
#   group_by(Archetype, Sideboard_CardName) %>%
#   filter(n() > 1)
```




```{r uncommon_cards}
Uncommon_cards_pre_process <- Df_archetype_cards_agreg %>%
  # filter(count_iteration_cards == most_common_count) %>%
  filter(
    (Archetype_count - most_common_count) >= min_sample_size_5,
    # most_common_count >= min_sample_size_5
    # (Archetype_count - total_number_of_copie) >= min_sample_size_5,
    total_number_of_copie >= min_sample_size_5
  ) %>%
  group_by(Archetype, Mainboard_CardName) %>%
  mutate(
    # Choix de prendre la plus faible quantité en cas d'éaglité pour le plus commun
    most_common_quantity = Mainboard_Count[count_iteration_cards == max(count_iteration_cards)][1],
    min_count_group = Mainboard_Count
  )




Uncommon_cards_agreg_out <- Agreg_count_by_cards(
  Uncommon_cards_pre_process,
  "Mainboard",
  min_sample_size_5
)

Uncommon_cards <- Uncommon_cards_agreg_out %>%
  group_by(Archetype, Mainboard_CardName)
```


```{r Side_uncommon_cards}
Side_Uncommon_cards_pre_process <- Df_side_archetype_cards_agreg %>%
  # filter(count_iteration_cards == most_common_count) %>%
  filter(
    (Archetype_count - most_common_count) >= min_sample_size_5,
    # most_common_count >= min_sample_size_5
    # (Archetype_count - total_number_of_copie) >= min_sample_size_5,
    total_number_of_copie >= min_sample_size_5
  ) %>%
  group_by(Archetype, Sideboard_CardName) %>%
  mutate(
    # Choix de prendre la plus faible quantité en cas d'éaglité pour le plus commun
    most_common_quantity = Sideboard_Count[count_iteration_cards == max(count_iteration_cards)][1],
    min_count_group = Sideboard_Count
  )




Side_Uncommon_cards_agreg_out <- Agreg_count_by_cards(
  Side_Uncommon_cards_pre_process,
  "Sideboard",
  min_sample_size_5
)

Side_Uncommon_cards <- Side_Uncommon_cards_agreg_out %>%
  group_by(Archetype, Sideboard_CardName)
```




```{r Base_cards_grouping_with_agreg}
# Récupération des cartes a 1 niveaux après agreg
Base_cards_and_base_count <- rbind(
  Df_archetype_cards_agreg %>%
    mutate(
      min_count_group = Mainboard_Count,
      most_common_quantity = Mainboard_Count
    ) %>%
    group_by(Archetype, Mainboard_CardName) %>%
    mutate(Mainboard_Count = paste0(Mainboard_Count, collapse = "/")) %>%
    ungroup() %>%
    filter(count_iteration_cards == most_common_count) %>%
    filter((Archetype_count - most_common_count) < min_sample_size_5),
  Uncommon_cards_agreg_out %>%
    group_by(Archetype, Mainboard_CardName) %>%
    filter(n() == 1)
) %>%
  rowwise() %>%
  mutate(Mainboard_Count = paste0(findIntRuns(as.numeric(unlist(str_split(Mainboard_Count, "/")))), collapse = "/")) %>%
  ungroup() %>%
  left_join(Deck_win_rate_join,by = "Archetype") %>% 
  group_split(Archetype) %>%
  name_list_of_df_with_arch()
```


```{r Side_Base_cards_grouping_with_agreg}
# Récupération des cartes a 1 niveaux après agreg
Side_Base_cards_and_base_count <- rbind(
  Df_side_archetype_cards_agreg %>%
    mutate(
      min_count_group = Sideboard_Count,
      most_common_quantity = Sideboard_Count
    ) %>%
    group_by(Archetype, Sideboard_CardName) %>%
    mutate(Sideboard_Count = paste0(Sideboard_Count, collapse = "/")) %>%
    ungroup() %>%
    filter(count_iteration_cards == most_common_count) %>%
    filter((Archetype_count - most_common_count) < min_sample_size_5),
  Side_Uncommon_cards_agreg_out %>%
    group_by(Archetype, Sideboard_CardName) %>%
    filter(n() == 1)
) %>%
  rowwise() %>%
  mutate(Sideboard_Count = paste0(findIntRuns(as.numeric(unlist(str_split(Sideboard_Count, "/")))), collapse = "/")) %>%
  ungroup() %>%
  left_join(Deck_win_rate_join,by = "Archetype") %>% 
  group_split(Archetype) %>%
  name_list_of_df_with_arch()
```




```{r groupe_cards}
compute_pairwise_table <- function(df_fun_cor_cat,seuil_common_sup = 0.9){
  
list_of_pairwise_table <- lapply(
  apply(combn(names(df_fun_cor_cat), 2), 2, 
                                       function(i) df_fun_cor_cat[i]),
  function(x) {
    card_name <-  colnames(x)
    df_en_cours <-  x %>% 
        rename(card1 = 1,
          card2 = 2,
          ) %>% 
  filter(!(card1 == "0" & card2 == "0"))
    
    count_card1 <- df_en_cours %>%
    count(card1) %>% 
      rename(count_card1 = 1 ,
             n_card1 = 2
             ) %>% 
      mutate(
        card1 = card_name[1],
           total_card1 = sum(df_en_cours$card1 !=0)
          ) 
    
    count_card2 <- df_en_cours %>%
    count(card2) %>% 
      rename(
        count_card2 = 1 ,
        n_card2 = 2     
             ) %>% 
      mutate(card2 = card_name[2],
             total_card2 = sum(df_en_cours$card2 !=0)
             )
    
    # slower 134.33 sec vs 77.32 sec
     # x %>% 
     #  count(., !!!.) %>% 
  res <-  as.data.frame(table(x)) %>%
  mutate(card1 = card_name[1],
         .before = 1
         ) %>%
  mutate(
      card2 = card_name[2],
      .before = 3
  ) %>%
  rename(count_card1 = 2,
         count_card2 = 4,
         ) %>% 
   left_join(count_card1,by = join_by(card1, count_card1)) %>% 
    left_join(count_card2,by = join_by(card2, count_card2))
  
  return(res)
  }
# )
  ) %>%
  bind_rows() %>% 
  filter(!(card1 == "0" & card2 == "0")) %>%
  filter(!(count_card1 == 0 | count_card2 == 0)) %>%
  filter(Freq != 0) %>%
  rowwise() %>%
  mutate(
    MIN_COL_name = c("card1","card2")[which.min(c_across(c(n_card1,n_card2)))],
    min_common_support = min(n_card1,n_card2),
    percent_support = Freq/min_common_support
    ) %>%
  select(-c(n_card1,n_card2)) %>% 
  group_by(card1,card2) %>% 
  mutate(
    perc1 = sum(Freq)/unique(total_card1),
    perc2 = sum(Freq)/unique(total_card2)
  ) %>% 
  ungroup() %>% 
  mutate(perc = perc1 + perc2) %>% 
    filter(
    perc > (seuil_common_sup * 2)   ) %>%
  # filter(
  #   perc1 > seuil_common_sup|
  #   perc2 > seuil_common_sup    ) %>%
  select(-c( perc1 ,perc2)) %>% 
  arrange(desc(percent_support)) %>%
  mutate(
    card1_agreg = paste0(
            card1, " : ", count_card1
          ),
   card2_agreg = paste0(
            card2, " : ", count_card2
          )
  )

return(list_of_pairwise_table)
}

##########################################################################################################################################################################################################

most_common_association <- function(table_res){
card_to_choose <- table_res
select_row <- table_res %>% 
  slice_max(perc, n = 1, with_ties = FALSE)

while (nrow(card_to_choose) !=0 ) {
  card_to_choose <- card_to_choose %>% 
    filter(card1 %notin% c(
      select_row$card1,
      select_row$card2
      ),
      card2 %notin% c(
      select_row$card1,
      select_row$card2
      )
      )
  if(nrow(card_to_choose) != 0){
    select_row <- rbind(
      select_row,
      card_to_choose  %>% 
  slice_max(perc, n = 1, with_ties = FALSE) 
        
      )
   }
res <- select_row %>% 
  select(-c(
    card2_agreg,
    card1_agreg,
    Freq,
    MIN_COL_name,
    min_common_support
    ))   
}


return(res)
}


##########################################################################################################################################################################################################

group_variable_function <- function(df_arch_init,n = 1){

   Archetype_en_cours <- unique(df_arch_init$Archetype)

    df_fun_cor_cat_arch <- df_arch_init %>%
      select(-c(
        id 
      )) %>%
      select(-ends_with(" land"), -any_of("Land_tot")) %>%
      select(where(~ n_distinct(.) > 1))

    if (ncol(df_fun_cor_cat_arch) == 0) {
      # list_of_pairwise_table <- NULL
      micro_res_table_most_common_test <- NULL
    } else {
      list_of_pairwise_table_en_cours <- compute_pairwise_table(
        df_fun_cor_cat = df_fun_cor_cat_arch,
        seuil_common_sup = 0.98
      )
      if (nrow(list_of_pairwise_table_en_cours) == 0) {
        micro_res_table_most_common_test <- NULL
      } else {
        micro_res_table_most_common_test <- most_common_association(
          table_res = list_of_pairwise_table_en_cours
        ) %>%
          distinct(card1, card2)
        # %>%
        #   mutate(Archetype = Archetype_en_cours,.before = 1)
      }
    }

if(is.null(micro_res_table_most_common_test)){
  res <- df_arch_init
} else {
  
  # print(n)
df_arch_res <- df_arch_init
    for (i in 1:nrow(micro_res_table_most_common_test)) {
      df_arch_res <- df_arch_res %>%
        mutate(
          !!rlang::sym(paste0(
            micro_res_table_most_common_test[i, ]$card1,
            " : ",
            micro_res_table_most_common_test[i, ]$card2
          )) :=
            paste0(
              !!rlang::sym(
                micro_res_table_most_common_test[i, ]$card1
              ),
              " : ",
              !!rlang::sym(
                micro_res_table_most_common_test[i, ]$card2
              )
            )
        ) %>%
      select(
        -all_of(
          c(
            micro_res_table_most_common_test[i, ]$card1,
            micro_res_table_most_common_test[i, ]$card2
          )
        )
      )
    }
 res <- group_variable_function(df_arch_res,n = n+1)
}

return(res)
}

```





```{r model_unco_cards}
Model_data_Uncommon_cards <- prepare_df_for_model(
  df_fun = Uncommon_cards,
  base_df = Df_archetype_cards_land_name_agreg,
  cols_fun = "Mainboard"
  ) 

```



```{r}
# tictoc::tic("table cards")
df_uncommon_cards_grouping_fun <- Model_data_Uncommon_cards  %>% 
  ungroup() %>%
  pivot_wider(
    names_from = Mainboard_CardName,
    values_from = Mainboard_Count,
     values_fill = "0",
    id_cols = c(Archetype,id)
    )  %>% 
  group_split(Archetype)

all_archetype_table_for_all_cards <- lapply(
  df_uncommon_cards_grouping_fun,
  function(x) {
    res_iteration <- group_variable_function(df_arch_init = x)
    res <- res_iteration %>% 
      pivot_longer(
        cols = -c(Archetype,id),
        names_to = "Mainboard_CardName",
        values_to = "Mainboard_Count"
                   )
    return(res)
  }
) %>% 
  bind_rows() 


# tictoc::toc()
```







```{r}
groupe_cards_uncommon_data  <- all_archetype_table_for_all_cards %>% 
  filter(Mainboard_Count != "0") %>% 
  left_join(
    (Model_data_Uncommon_cards %>%
              select(-c(Mainboard_CardName,Mainboard_Count,-Join_main_count)) %>% 
              distinct(id,.keep_all = TRUE)),
            by = join_by(
   Archetype,id
  )
  )
```



```{r}
# a <- groupe_cards_uncommon_data %>% 
#   filter(str_detect(Mainboard_CardName, " : ")) %>% 
#   group_by(Archetype,Mainboard_CardName,Mainboard_Count) %>% 
#   summarise(n =n(),
#             .groups = "drop") %>% 
#   group_by(Archetype,Mainboard_CardName) %>% 
#   mutate(max = max(n)) %>% 
#   group_split()

# b <- a [[1]]
# 
# d <- b %>% 
#   separate_wider_delim (Mainboard_Count, " : ",
#                         names_sep = "_")
```


```{r}
# Projet avec les images des cartes pour arborescence deck list penser a mettre en gras le compte le plus rreprésenter pour base card and base count
result_models_Uncommon_cards_all_arch <- model_unco_cards_fun(
  df_fun = groupe_cards_uncommon_data,
  # Model_data_Uncommon_cards, 
  cols_fun = "Mainboard"
  ) %>%
  name_list_of_model_with_string(unique(groupe_cards_uncommon_data$Archetype))
```




```{r format_main_models}
uncomon_card_format_model <- format_model_list(result_models_Uncommon_cards_all_arch) %>%
  name_list_of_model_with_string(unique(groupe_cards_uncommon_data$Archetype))
```




```{r side_model_unco_cards}
Side_Model_data_Uncommon_cards <-  prepare_df_for_model(
  df_fun = Side_Uncommon_cards,
  base_df = df_side_Archetype_long,
  cols_fun = "Sideboard"
  )
# Projet avec les images des cartes pour arborescence deck list penser a mettre en gras le compte le plus rreprésenter pour base card and base count
```



```{r}
# tictoc::tic("table cards")
df_uncommon_side_cards_grouping_fun <- Side_Model_data_Uncommon_cards  %>% 
  ungroup() %>%
  pivot_wider(
    names_from = Sideboard_CardName,
    values_from = Sideboard_Count,
     values_fill = "0",
    id_cols = c(Archetype,id)
    )  %>% 
  group_split(Archetype)


all_archetype_table_for_side_all_cards <- lapply(
  df_uncommon_side_cards_grouping_fun,
  function(x) {
    # print(as.character(unique(x$Archetype)))
    res_iteration <- group_variable_function(df_arch_init = x)

    res <- res_iteration %>% 
      pivot_longer(
        cols = -c(Archetype,id),
        names_to = "Sideboard_CardName",
        values_to = "Sideboard_Count"
                   )
    return(res)
  }
) %>% 
  bind_rows() 


# tictoc::toc()
```


```{r}
groupe_side_cards_uncommon_data  <- all_archetype_table_for_side_all_cards %>% 
  filter(Sideboard_Count != "0") %>% 
  left_join(
    (Side_Model_data_Uncommon_cards %>%
              select(-c(Sideboard_CardName,Sideboard_Count,-Join_main_count)) %>% 
              distinct(id,.keep_all = TRUE)),
            by = join_by(
   Archetype,id
  )
  ) 
```


```{r}
Side_result_models_Uncommon_cards_all_arch <- model_unco_cards_fun(groupe_side_cards_uncommon_data, "Sideboard") %>%
  name_list_of_model_with_string(unique(groupe_side_cards_uncommon_data$Archetype))
```




```{r format_side_models}
Side_uncomon_card_format_model <- format_model_list(Side_result_models_Uncommon_cards_all_arch) %>%
  name_list_of_model_with_string(unique(groupe_side_cards_uncommon_data$Archetype))
```



```{r compute_vif}
compute_vif_for_model <- function(res_model){
res_fun <- lapply(res_model, function (x){
  
res_per_arch <- lapply(seq_along(x), function(y){
  model_vif_fun <- x[[y]]
  
  
  if  (length(coefficients(model_vif_fun))  < 3){
  res <- data.frame(
    model = names(x[y]),
    name = "a",
    Df = 1,
    vif = 0
    ) %>% as_tibble()
    
  } else{
  vif_res <- car::vif(model_vif_fun)
  

  
  if(is.null(ncol(vif_res))){
  res <- data.frame(
    model = names(x[y]),
    name = names(vif_res),
    Df = 1,
    vif = vif_res
    ) %>% as_tibble() %>% 
    arrange(desc(vif))
} else {
  res = as.data.frame(vif_res) %>% 
    rownames_to_column("name") %>% 
    as_tibble() %>% 
    mutate(model = names(x[y]),
         .before = 1) %>% 
    select(-GVIF) %>% 
    rename(vif = `GVIF^(1/(2*Df))`) %>% 
    arrange(desc(vif))
  }
}}
) %>% 
  bind_rows() %>% 
  mutate(Archetype = x$Model_any$Archetype,
         .before = 1)  %>%  
  filter(vif > 3)
  
}) %>% 
  bind_rows()
return(res_fun)
}


```


```{r}

vif_deck <- rbind(
  compute_vif_for_model(result_models_Uncommon_cards_all_arch) %>% 
    mutate(
      deck_side = "Main",.before = 1
      ),
  compute_vif_for_model(Side_result_models_Uncommon_cards_all_arch) %>% 
    mutate(
      deck_side = "Main",.before = 1
      )
  )

```


```{r print_result, results='asis', out.width="100%"}
if(is_inside_knitr()){
for (i in sort(levels(df_Archetype_long$Archetype))) {
  # Inserts Month titles
  pander::pandoc.header(i, level = 1)
  # Section contents
  pander::pandoc.header("Main deck", level = 2)
  pander::pandoc.p("")


  if (i %in% names(Base_cards_and_base_count)) {
  pander::pandoc.header("Base Cards", level = 3)
  pander::pandoc.p("")
  pander::pandoc.p("Cards Always in deck with nearly fix count")
  pander::pandoc.p("")

    flextable::flextable_to_rmd(
      flextable::flextable(
        Base_cards_and_base_count[[i]] %>%
          mutate(
            WR = paste0(round(((Wins  / (Wins + Losses)) - Archetype_winrate)* 100, 2), " %"),
            Not_most_common_count = total_number_of_copie - most_common_count,
            Card_not_in_deck = Archetype_count - total_number_of_copie
          ) %>%
          select(
            Mainboard_CardName, WR, Mainboard_Count,
            most_common_quantity, Card_not_in_deck, Not_most_common_count
          )
      ) %>% flextable::align(align = "center", part = "all")
    )
  }


  if (i %in% names(uncomon_card_format_model)) {
  pander::pandoc.header("Variable Cards", level = 3)
  pander::pandoc.p("")
  pander::pandoc.p("Cards not always in deck using binomial regression for WR")
  pander::pandoc.p("")
    pander::pandoc.p('::: {.panel-tabset .nav-pills}')
if (!is.null(uncomon_card_format_model[[i]]$Model_any)) {
    pander::pandoc.header("Any", level = 4)
    flextable::flextable_to_rmd(
      uncomon_card_format_model[[i]]$Model_any %>%
        gtsummary::as_flex_table()
    )
}
    pander::pandoc.p("")
    # pander::pandoc.p(":::")
    #
    # pander::pandoc.p('::: {.column width="50%"}')
    pander::pandoc.p("")
    if (!is.null(uncomon_card_format_model[[i]]$Model_count )) {
    pander::pandoc.header("Count", level = 4)
    flextable::flextable_to_rmd(
      uncomon_card_format_model[[i]]$Model_count %>%
        gtsummary::as_flex_table()
    )
}
#     pander::pandoc.p(":::
# ::::::::::::::")
    pander::pandoc.p(":::")
  }
  # adding also empty lines, to be sure that this is valid Markdown
  pander::pandoc.p("")
  pander::pandoc.p("")

  pander::pandoc.header("Side Board", level = 2)
  pander::pandoc.p("")


  if (i %in% names(Side_Base_cards_and_base_count)) {
  pander::pandoc.header("Base Cards", level = 3)
  pander::pandoc.p("")
  pander::pandoc.p("Cards Always in deck with nearly fix count")
  pander::pandoc.p("")
   flextable::flextable_to_rmd(
      flextable::flextable(
        Side_Base_cards_and_base_count[[i]] %>%
          mutate(
            WR = paste0(round(((Wins  / (Wins + Losses)) - Archetype_winrate)* 100, 2), " %"),
            Not_most_common_count = total_number_of_copie - most_common_count,
            Card_not_in_deck = Archetype_count - total_number_of_copie
          ) %>%
          select(
            Sideboard_CardName, WR, Sideboard_Count,
            most_common_quantity, Card_not_in_deck, Not_most_common_count
          )
      ) %>%
        flextable::align(align = "center", part = "all")
    )
  }

  if (i %in% names(uncomon_card_format_model)) {
  pander::pandoc.header("Variable Cards", level = 3)
  pander::pandoc.p("")
  pander::pandoc.p("Cards not always in deck using binomial regression for WR")
  pander::pandoc.p("")

#     pander::pandoc.p(':::::::::::::: {.columns}
# ::: {.column width="50%"}')

    pander::pandoc.p('::: {.panel-tabset .nav-pills}')
    if (!is.null(Side_uncomon_card_format_model[[i]]$Model_any)) {
       pander::pandoc.header("Any", level = 4)
    flextable::flextable_to_rmd(
      Side_uncomon_card_format_model[[i]]$Model_any %>%
        gtsummary::as_flex_table()
    )
}
    # pander::pandoc.p(":::")
    #
    # pander::pandoc.p('::: {.column width="50%"}')
    pander::pandoc.p("")
if (!is.null(Side_uncomon_card_format_model[[i]]$Model_count)) {
     pander::pandoc.header("Count", level = 4)
    flextable::flextable_to_rmd(
      Side_uncomon_card_format_model[[i]]$Model_count %>%
        gtsummary::as_flex_table()
    )
}
#     pander::pandoc.p(":::
# ::::::::::::::")
    pander::pandoc.p(":::")
  }
  # adding also empty lines, to be sure that this is valid Markdown
  pander::pandoc.p("")
  pander::pandoc.p("")



  pander::pandoc.p("")
  pander::pandoc.p("")
}
  }
```








