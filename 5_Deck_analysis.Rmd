---
title: "Deck winrate Analysis"
output: 
  html_document:
date: "`r Sys.Date()`"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "outpout/result") })
---

```{r setup, include=FALSE, message = FALSE, warning = FALSE} 
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE
)
library(pander)
library("rjson")
library(tidyverse)

source("S2_Source_mtg_new_card.R")

# loaded_base_data <- readRDS("data/data_meta_en_cours.rds")




modern_DB_card <- read_csv("data/DBcarte_modern.csv")

# sample size minimum pour etre un groupe
min_sample_size = 50

Land_modern <- modern_DB_card %>% 
  filter(str_detect(type_line,"Land|land") ) %>% 
  # Remove dfc land exept dfc land // land
  filter(
    !str_detect(
      type_line,
      "(?<!Land )// Land") 
    ) %>% 
    { . ->> tmp } %>% filter(str_detect(name,".+ //")) %>% 
  mutate(name = str_remove(name," // .+")) %>% rbind(tmp)

rm(tmp)


filter_archetype_count <-  300


df_export <- readRDS("data/data_meta_en_cours.rds") %>% 
  mutate(
    Deck_winrate = Wins / (Losses + Wins)
  ) %>%
  mutate(
    Archetype_count = n()
  )
```

```{r function}

findIntRuns <- function(run){
  rundiff <- c(1, diff(run))
  difflist <- split(run, cumsum(rundiff!=1))
  unlist(lapply(difflist, function(x){
    if(length(x) %in% 1:2) as.character(x) else paste0(x[1], "-", x[length(x)])
  }), use.names=FALSE)
}






Agreg_count_by_cards <- function(df,
                                 min_sample_size_fun = min_sample_size
){

  df_result <- df %>% 
    mutate(
      grouping_sens = if_else((min_count_group - most_common_quantity) <0,
                              "up","botom")) %>% 
    group_by(Archetype ,Mainboard_CardName) %>% 
    mutate(
      need_group = count_iteration_cards < min_sample_size_fun,
      no_group_needed = any(need_group),
      grouping_this_iter = 
        (min_count_group == suppressWarnings(min(min_count_group[need_group])) |
           min_count_group == suppressWarnings(max(min_count_group[need_group]))
         
        )
    ) %>% 
    ungroup() %>% 
    mutate(
      new_count =
        if_else(
          (count_iteration_cards  < min_sample_size_fun & grouping_sens == "up" & grouping_this_iter)  ,
          count_iteration_cards  + lead(count_iteration_cards),
          if_else(
            (count_iteration_cards  < min_sample_size_fun & grouping_sens == "botom" & grouping_this_iter) ,
            count_iteration_cards  + lag(count_iteration_cards),
            count_iteration_cards 
          )
        ),
      new_count = if_else(
        (lag(count_iteration_cards)  < min_sample_size_fun &
           lag(grouping_sens) == "up" & 
           !is.na(lag(count_iteration_cards)) &
           lag(grouping_this_iter)
         
        ),
        lag(new_count),
        if_else(
          (
            lead(count_iteration_cards)  < min_sample_size_fun & 
              lead(grouping_sens) == "botom" & 
              !is.na(lead(count_iteration_cards)) &
              lead(grouping_this_iter)
            
          ),
          lead(new_count),
          new_count
        )
        )
      ) %>% 
    group_by(
      Archetype,Archetype_count,Mainboard_CardName,total_number_of_copie,
      most_common_count,most_common_quantity,new_count
    ) %>% 
    summarise(
      Wins = sum(Wins),
      Losses = sum(Losses),
      min_count_group = min(min_count_group),
      Mainboard_Count = paste0(Mainboard_Count,collapse = "/"),
      .groups = "drop") %>% 
    rename(count_iteration_cards = new_count) %>% 
    arrange(Archetype,Mainboard_CardName,min_count_group) %>% 
    select(
      Archetype,Archetype_count, Mainboard_CardName,Mainboard_Count,Wins,Losses,
      count_iteration_cards,total_number_of_copie , most_common_count, most_common_quantity ,
      min_count_group
    )
  
  
  
  df_temp_check <- df_result %>% 
    mutate(
      need_group = count_iteration_cards < min_sample_size_fun
    )
  
  if(
    all(!df_temp_check$need_group)
  ){
    df_final <- df_result
  } else {
    df_final <- Agreg_count_by_cards(
      df_result,
      min_sample_size_fun = min_sample_size_fun
    )
  }
  
  
  return(df_final)
  
}



get_inertia_from_tree <- function(tree, k_max = 15) {
  if (inherits(tree, "HCPC"))
    tree <- tree$call$t$tree
  if (!inherits(tree, "hclust"))
    tree <- as.hclust(tree)
  inertia <- tree$height |> 
    sort(decreasing = TRUE) |> 
    head(k_max)
  prev_inertia <- dplyr::lag(inertia)
  dplyr::tibble(
    k = seq_along(inertia),
    inertia = inertia,
    absolute_loss = inertia - prev_inertia,
    relative_loss = (inertia - prev_inertia) / prev_inertia
  )
}

plot_inertia_from_tree <- function(tree, k_max = 15) {
  d <- get_inertia_from_tree(tree, k_max)
  p_inertia <- 
    ggplot2::ggplot(d) +
    ggplot2::aes(x = k, y = inertia) +
    ggplot2::geom_step() +
    ggplot2::ylab("Inertia")
  p_absolute <-
    ggplot2::ggplot(d) +
    ggplot2::aes(x = k, y = absolute_loss) +
    ggplot2::geom_bar(stat = "identity", fill = "#4477AA") +
    ggplot2::ylab("Absolute loss")
  p_relative <-
    ggplot2::ggplot(d) +
    ggplot2::aes(x = k, y = relative_loss) +
    ggplot2::geom_line(color = "#AA3377") +
    ggplot2::geom_point(size = 3, color = "#AA3377") +
    ggplot2::scale_y_continuous(label = scales::percent) +
    ggplot2::ylab("Relative loss")
  patchwork::wrap_plots(
    p_inertia,
    p_absolute,
    p_relative,
    ncol = 1
  ) &
    ggplot2::theme_light() &
    ggplot2::xlab("Number of clusters") &
    ggplot2::scale_x_continuous(
      breaks = d$k,
      minor_breaks = NULL,
      limits = c(1, k_max)
    )
}


format_model_list <- function(model_list){
model_clean <-  lapply(model_list, function(x){
 x %>%
    gtsummary::tbl_regression(exponentiate	 = TRUE) %>%
    gtsummary::bold_labels() %>%
    gtsummary::add_n(location = "level") %>%
    gtsummary::modify_spanning_header(
        c(stat_n,estimate, ci, p.value) ~
        paste0("**",x$Archetype," N :",
               sum(x$data$Wins + x$data$Losses),
               "**")
      )
    }
    )
  return(model_clean)
}
```



```{r agreg_land_name}
df_Archetype_long <-  df_export %>% 
  filter(!is.na(Wins)) %>% 
  rowwise() %>% 
  filter(!is.null(Mainboard)) %>% 
  filter(!is.null(Sideboard)) %>% 
  ungroup() %>% 
  group_by(Archetype) %>%
  mutate(
    Archetype_count = n()
  ) %>% 
  filter(Archetype_count > filter_archetype_count) %>% 
  arrange(desc(Archetype_count)) %>% 
  unnest_longer(Mainboard) %>%
  unnest_wider(Mainboard,names_sep = "_") %>% 
  # mutate(Mainboard_CardName = Card_agregueur(Mainboard_CardName)) %>%
  select(id,Player,Wins, Losses ,Draws ,Archetype,Mainboard_Count,Mainboard_CardName)  %>% 
  group_by(id) %>% 
  mutate(Number_of_cards = sum(Mainboard_Count)) %>% 
  filter(Number_of_cards >= 60) 




Df_archetype_cards_land_name_agreg <- rbind(
  df_Archetype_long %>% 
  group_by(Archetype) %>% 
  mutate(Archetype_count = n_distinct(id)) %>% 
 mutate(
   Mainboard_CardName = 
    Card_agregueur(
      Mainboard_CardName,
      fetch = TRUE,
      Tron = TRUE,
      snow = TRUE,
      surveil = TRUE,
      shock = TRUE,
      triome = TRUE,
      filter_land = TRUE,
      fast_land = TRUE,
      bounce_land = TRUE,
      horizon_land = TRUE,
      basic_land = TRUE
           )
   ) %>% 
  ungroup() %>% 
  group_by(id,Mainboard_CardName) %>% 
  mutate(
    Mainboard_Count = sum(Mainboard_Count)) %>% 
  distinct(id,Mainboard_CardName,.keep_all = TRUE),
df_Archetype_long %>% 
  mutate(Mainboard_Count = if_else(
    Mainboard_CardName %in% Land_modern$name,
    Mainboard_Count,0),
    Mainboard_CardName = "Land_tot"
    ) %>% 
  group_by(id) %>% 
  mutate(  
    Mainboard_Count = sum(Mainboard_Count)
    ) %>% 
    ungroup() %>% 
    group_by(Archetype) %>% 
  mutate(Archetype_count = n_distinct(id)) %>% 
    ungroup() %>% 
  distinct() ) %>% 
  arrange(desc(Archetype_count),id)



Df_archetype_cards_agreg <- Df_archetype_cards_land_name_agreg %>% 
  group_by(Archetype,Archetype_count,Mainboard_CardName,Mainboard_Count) %>% 
  summarise(
    Wins = sum(Wins),
    Losses = sum(Losses),
    count_iteration_cards = n(),
    .groups = "drop"
    ) %>% 
  group_by(Archetype,Mainboard_CardName) %>% 
  mutate(
    Wins = sum(Wins),
    Losses = sum(Losses),
    total_number_of_copie = sum(count_iteration_cards),
    most_common_count = max(count_iteration_cards)
    ) 
```



```{r base_card_and_variable_count}
# First because of cards with 1 level after agreg
Base_cards_and_variable_count_pre_process <- Df_archetype_cards_agreg %>% 
  # filter(count_iteration_cards == most_common_count) %>% 
  filter( 
    (Archetype_count  - most_common_count) >= min_sample_size,
    # most_common_count >= min_sample_size
    (Archetype_count  - total_number_of_copie ) < min_sample_size
  )  %>% 
  group_by(Archetype,Mainboard_CardName) %>% 
  mutate(
    # Choix de prendre la plus faible quantité en cas d'éaglité pour le plus commun
    most_common_quantity = Mainboard_Count[count_iteration_cards==max(count_iteration_cards)][1],
    min_count_group = Mainboard_Count
  )

Base_cards_and_variable_count_agreg_out <- Agreg_count_by_cards(
  Base_cards_and_variable_count_pre_process
) 

Base_cards_and_variable_count <- Base_cards_and_variable_count_agreg_out %>% 
  group_by(Archetype,Mainboard_CardName) %>% 
  filter(n() > 1)
```




```{r uncommon_cards}
Uncommon_cards_pre_process <- Df_archetype_cards_agreg %>% 
  # filter(count_iteration_cards == most_common_count) %>% 
  filter( 
    (Archetype_count  - most_common_count) >= min_sample_size,
    # most_common_count >= min_sample_size
    (Archetype_count  - total_number_of_copie ) >= min_sample_size,
    total_number_of_copie >= min_sample_size
  )  %>% 
  group_by(Archetype,Mainboard_CardName) %>% 
  mutate(
    # Choix de prendre la plus faible quantité en cas d'éaglité pour le plus commun
    most_common_quantity = Mainboard_Count[count_iteration_cards==max(count_iteration_cards)][1],
    min_count_group = Mainboard_Count
  )




Uncommon_cards_agreg_out <- Agreg_count_by_cards(
  Uncommon_cards_pre_process
) 

Uncommon_cards <- Uncommon_cards_agreg_out %>% 
  group_by(Archetype,Mainboard_CardName) 
```




```{r}
# Récupération des cartes a 1 niveaux après agreg
Base_cards_and_base_count <- rbind(
  Df_archetype_cards_agreg %>% 
    mutate(min_count_group = Mainboard_Count,
           most_common_quantity = Mainboard_Count
    ) %>% 
    group_by(Archetype,Mainboard_CardName) %>% 
    mutate(Mainboard_Count = paste0(Mainboard_Count,collapse = "/")) %>% 
    ungroup() %>% 
    filter(count_iteration_cards == most_common_count) %>% 
    filter((Archetype_count  - most_common_count) < min_sample_size),
Base_cards_and_variable_count_agreg_out %>% 
  group_by(Archetype,Mainboard_CardName) %>% 
  filter(n() == 1)
) %>% 
  rowwise() %>% 
  mutate(Mainboard_Count = paste0(findIntRuns(as.numeric(unlist(str_split(Mainboard_Count,"/")))),collapse = "/" )) %>% 
  ungroup() %>%  
  
  group_split(Archetype)

```






```{r mdoel_based_cards}
Model_data_base_cards  <- Base_cards_and_variable_count %>%
  rowwise() %>%
  mutate(Join_main_count = list(
    as.numeric(unlist(strsplit(Mainboard_Count, "/")))
    )
    ) %>% 
  ungroup() %>% 
  unnest_longer(Join_main_count) %>% 
  select(
    Archetype,Archetype_count,Mainboard_CardName,
    Mainboard_Count,Join_main_count#,most_common_quantity 
    ) %>% 
  right_join(
    Df_archetype_cards_land_name_agreg,
    by = c("Archetype","Archetype_count","Mainboard_CardName","Join_main_count" = "Mainboard_Count")
  ) 



# Intégré base card and base count
# Projet avec les images des cartes pour arborescence deck list penser a mettre en gras le compte le plus rreprésenter pour base card and base count
# regression just of number of cards
result_models_variable_count_all_arch <- lapply(
  unique(Model_data_base_cards$Archetype),
  function(x) {
  df_model <-  Model_data_base_cards %>% 
    select(-Join_main_count) %>% 
    filter(Archetype == x)  %>%
    ungroup() %>%  
    filter(!is.na(Mainboard_Count)) %>% 
  rowwise() %>% 
  mutate(Mainboard_Count = paste0(findIntRuns(as.numeric(unlist(str_split(Mainboard_Count,"/")))),collapse = "/" )) %>% 
  ungroup() %>%  
    pivot_wider(
      names_from = Mainboard_CardName,
      values_from = Mainboard_Count,
      values_fill = NA
    ) %>% 
    mutate(
      # Groupe les rares manquant <50 avec le groupe le plus larges probablement a réfléchir
      across(-1,
             ~ifelse(is.na(.),
                     names(sort(table(.),
                                decreasing = TRUE))[1],
                     .)
                  )
           ) %>% 
    select(-Archetype,-Player,-id,-Archetype_count,-Draws) %>% 
  mutate(
    # Choose most common level as references
    across(where(is.character),
           ~fct_infreq(as.factor(.))
    )
  )
  
  model_res <- glm(cbind(Wins , Losses ) ~ .,
                 data = df_model,
                 family = binomial)

  
  model_res$Archetype <- x
  
  return(model_res)
})

```




```{r model_unco_cards}
Model_data_Uncommon_cards  <- Uncommon_cards %>%
  rowwise() %>%
  mutate(Join_main_count = list(
    as.numeric(unlist(strsplit(Mainboard_Count, "/")))
    )
    ) %>% 
  ungroup() %>% 
  unnest_longer(Join_main_count) %>% 
  select(
    Archetype,Archetype_count,Mainboard_CardName,
    Mainboard_Count,Join_main_count#,most_common_quantity 
    ) %>% 
  right_join(
    Df_archetype_cards_land_name_agreg,
    by = c("Archetype","Archetype_count","Mainboard_CardName","Join_main_count" = "Mainboard_Count")
  ) 


# Projet avec les images des cartes pour arborescence deck list penser a mettre en gras le compte le plus rreprésenter pour base card and base count

result_models_Uncommon_cards_all_arch <- lapply(
  unique(Model_data_Uncommon_cards$Archetype),
  function(x) {
  df_model <-  Model_data_Uncommon_cards %>% 
    select(-Join_main_count) %>% 
    filter(Archetype == x)  %>%
    ungroup() %>%  
    filter(!is.na(Mainboard_Count  )) %>% 
  rowwise() %>% 
  mutate(Mainboard_Count = paste0(findIntRuns(as.numeric(unlist(str_split(Mainboard_Count,"/")))),collapse = "/" )) %>% 
  ungroup() %>% 
    pivot_wider(
      names_from = Mainboard_CardName,
      values_from = Mainboard_Count,
      values_fill = "0"
    ) %>% 
    select(-Archetype,-Player,-id,-Archetype_count,-Draws) %>% 
  mutate(
    # Choose most common level as references
    across(where(is.character),
           ~fct_infreq(as.factor(.))
    )
  )
  
  model_res <- glm(cbind(Wins , Losses ) ~ .,
                 data = df_model,
                 family = binomial)

  
  model_res$Archetype <- x
  return(model_res)
})
```







```{r}
# i <- 1
# uncomon_card_format_model[[i]]

```



```{r format_all_models}
Base_card_variable_count_format_model <- format_model_list(result_models_variable_count_all_arch)
uncomon_card_format_model <- format_model_list(result_models_Uncommon_cards_all_arch)

```

```{r print_result, results='asis'}

for (i in seq_along(Base_card_variable_count_format_model)) {
   # Inserts Month titles
   pander::pandoc.header(Base_cards_and_base_count[[i]]$Archetype[1] , level = 1)
   # Section contents
   pander::pandoc.header("Base Cards" , level = 2)
   pander::pandoc.p('')
   pander::pandoc.p('Cards Always in deck with nearly fix count')
   pander::pandoc.p('')
   flextable::flextable_to_rmd(
     flextable::flextable(
     Base_cards_and_base_count[[i]] %>% 
     mutate(WR = paste0(round(Wins*100/(Wins + Losses),2)," %"),
            Not_most_common_count = total_number_of_copie -count_iteration_cards
             ) %>%  
  select(Mainboard_CardName,WR,Mainboard_Count,
         most_common_quantity,Not_most_common_count)
  ) %>% flextable::align( align = "center", part = "all")
  )
   
   
    pander::pandoc.header("Base Cards Variable count" , level = 2)
   pander::pandoc.p('')
   pander::pandoc.p('Cards Always in deck with  different count using binomial regression for WR')
   pander::pandoc.p('')
   Base_card_variable_count_format_model[[i]] %>% print()
       pander::pandoc.header("Uncommon Cards" , level = 2)
   pander::pandoc.p('')
   pander::pandoc.p('Cards not always in deck using binomial regression for WR')
   pander::pandoc.p('')
   uncomon_card_format_model[[i]] %>% print()
   
   # adding also empty lines, to be sure that this is valid Markdown
   pander::pandoc.p('')
   pander::pandoc.p('')
}
```





